<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xLei_xpxp</title>
  
  <subtitle>人生有梦</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-16T03:29:20.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xLei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Task01_python基础和Numpy基础</title>
    <link href="http://yoursite.com/2020/12/16/Task01-python%E5%9F%BA%E7%A1%80%E5%92%8CNumpy%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/12/16/Task01-python%E5%9F%BA%E7%A1%80%E5%92%8CNumpy%E5%9F%BA%E7%A1%80/</id>
    <published>2020-12-16T03:25:56.000Z</published>
    <updated>2020-12-16T03:29:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、python基础"><a href="#一、python基础" class="headerlink" title="一、python基础"></a>一、python基础</h2><p>下面的python基础涉及python的基本数据结构等知识，本来想着在这里补充上的，试了一下发现并没有网上一些教程写的好，本着不重复造轮子的想法（其实就是懒）也就不加了，如果需要的话可参考廖雪峰的python教程</p><h3 id="1、列表推导式和条件赋值"><a href="#1、列表推导式和条件赋值" class="headerlink" title="1、列表推导式和条件赋值"></a>1、列表推导式和条件赋值</h3><p><strong>列表推导式</strong>：按照一定的语法帮助简化操作，可以较容易的获取一个列表，语法为<code>[A for i in B]</code>，其中<code>A</code>为函数名（需要注意的是别忘了要带参数比如：<code>A(i)</code>），<code>B</code>是一个迭代的对象。具体例子如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">[myfunc(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 结果如下</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 列表表达式还可以进行多层嵌套</span></span><br><span class="line">[x + y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>) <span class="keyword">for</span> y <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="comment">## 结果如下</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">## 个人理解：多层嵌套下相当于多重for循环，这个结果也验证了这个想法</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>条件赋值</strong>：类似<code>Java</code>的三目运算符的作用，语法为<code>a if condition else b</code>，翻译一下就是如果<code>condition</code>为<code>true</code>，则等于<code>a</code>，否则等于<code>b</code>，具体例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="number">1</span> <span class="keyword">if</span> <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## value结果如下</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>条件赋值也可结合列表使用，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[i <span class="keyword">if</span> i &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 结果如下</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="2、匿名函数与map方法"><a href="#2、匿名函数与map方法" class="headerlink" title="2、匿名函数与map方法"></a>2、匿名函数与map方法</h3><p><strong>匿名函数</strong>：顾名思义，匿名函数不需要函数名，在python中匿名函数可以借助<code>lambda</code>关键字实现，语法为<code>lambda 参数 ： 运算逻辑</code>，相当于封装了一组一次性的操作逻辑给使用者进行调用，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="keyword">lambda</span> x : x * <span class="number">2</span>)(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 结果如下</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>上述例子的用法很好理解，其实相当于列表推导式的语法，只不过这里的函数换成了<code>lambda x : x * 2</code>，匿名函数其实也可以给他“命名”以供多次调用，但是个人认为如果是这样的话应该还是封装成一个函数较好，这样易于读代码和维护代码。</p><p><strong>map方法</strong>：该方法提供了一种函数映射关系，例如我们上面的例子需要指定<code>i</code>为参数，使用map则只需要将函数和参数指定就可以产生映射关系，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map(<span class="keyword">lambda</span> x : x * <span class="number">2</span>, range(<span class="number">5</span>))</span><br><span class="line"><span class="comment">## 这样返回的是一个map对象，可用list函数转成list对象</span></span><br><span class="line">list(map(<span class="keyword">lambda</span> x : x * <span class="number">2</span>, range(<span class="number">5</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 对于多值输入的函数映射可以在后面添加迭代对象</span></span><br><span class="line">list(map(<span class="keyword">lambda</span> x , y : str(x) + <span class="string">'_'</span> + y, range(<span class="number">5</span>), list(<span class="string">'abcde'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">[<span class="string">'0_a'</span>, <span class="string">'1_b'</span>, <span class="string">'2_c'</span>, <span class="string">'3_d'</span>, <span class="string">'4_e'</span>]</span><br></pre></td></tr></table></figure><h3 id="3、zip对象与enumerate方法"><a href="#3、zip对象与enumerate方法" class="headerlink" title="3、zip对象与enumerate方法"></a>3、zip对象与enumerate方法</h3><hr><p><strong>zip对象</strong>：<code>zip</code>函数可以把多个可迭代的对象打包成一个元组，类型为<code>zip</code>类型，用<code>tuple</code>和<code>list</code>可以得到相应的结果，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L1, L2, L3 = list(<span class="string">'abc'</span>), list(<span class="string">'def'</span>), list(<span class="string">'hij'</span>)</span><br><span class="line">list(zip(L1,L2,L3))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">[(<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'h'</span>), (<span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>), (<span class="string">'c'</span>, <span class="string">'f'</span>, <span class="string">'j'</span>)]</span><br></pre></td></tr></table></figure><p>多个迭代对象往往会使用到<code>zip</code>函数，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, j, j <span class="keyword">in</span> zip(L1, L2, L3):</span><br><span class="line">    print(i, j, k)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">a d h</span><br><span class="line">b e i</span><br><span class="line">c f j</span><br></pre></td></tr></table></figure><p><code>zip</code>也可搭配<code>dict</code>使用，构成一个字典对象，例子如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict(zip(L1,L2))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="string">'d'</span>, <span class="string">'b'</span>: <span class="string">'e'</span>, <span class="string">'c'</span>: <span class="string">'f'</span>&#125;</span><br></pre></td></tr></table></figure><p>当然，python还提供了一个解压缩的方法，在<code>zip</code>对象前面加上<code>*</code>，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zipped = list(zip(L1,L2,L3))</span><br><span class="line">list(zip(*zipped))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line">[(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>), (<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>), (<span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>)]</span><br></pre></td></tr></table></figure><p><strong>enumerate方法</strong>：<code>enumerate</code>可以再迭代时绑定元素的遍历序号，例子如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(L1):</span><br><span class="line">    print(index, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行结果</span></span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br></pre></td></tr></table></figure><h2 id="二、Numpy基础"><a href="#二、Numpy基础" class="headerlink" title="二、Numpy基础"></a>二、Numpy基础</h2><p>这部分主要是了解一些<code>Numpy</code>库里api的用法，这里根据课件的分类做成一个工具，方便日后查找，有新的api用法也将进行补充：</p><h4 id="1-np数组的构造"><a href="#1-np数组的构造" class="headerlink" title="1.np数组的构造"></a>1.np数组的构造</h4><p>最基本的用法是通过<code>array</code>构造，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>构造一个等差序列</strong>： <code>np.linspace(起始，终止（包含），样本个数), np.arange（起始，终止（不包含），步长）</code>，注意的是包含和不包含表示这是一个左闭右开区间还是一个闭区间，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([<span class="number">0.</span>  , <span class="number">1.25</span>, <span class="number">2.5</span> , <span class="number">3.75</span>, <span class="number">5.</span>  ])</span><br><span class="line"></span><br><span class="line">np.arange(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">np.arange(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>构造一个特殊矩阵</strong>：</p><ul><li><code>np.zeros(矩阵维度)</code>：构造一个全0填充的矩阵</li><li><code>np.eye(单位矩阵的维度)</code>：构造一个单位矩阵，注意参数是一个数，单位矩阵是M*M的</li><li><code>np.full(矩阵维度，填充数值)</code>：构造一个指定维度的矩阵，使用指定数值进行填充，也可传入列表填充每列的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">np.eye(<span class="number">3</span>)</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">np.zeros((<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line">np.full((<span class="number">3</span>,<span class="number">3</span>),<span class="number">1</span>)</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">np.full((<span class="number">3</span>,<span class="number">3</span>),[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure><p><strong>构造一个随机矩阵</strong>：</p><ul><li><code>np.random.rand(n)</code>：生成服从<code>0-1分布</code>的<code>n</code>个随机数</li><li><code>np.random.randn(m, n)</code>：生成<code>M</code>行<code>N</code>列符合<code>标准正态分布</code>的矩阵</li><li><code>np.random.randInt(low, high, size)</code>：生成指定最小值<code>low</code>、最大值<code>high</code>（不包含）、维度<code>size</code>的随机整数矩阵</li><li><code>np.choice(list, size, replace=(true/false), p=p_list)</code>：从给定的<code>list</code>里按照<code>p_list</code>中的概率生成<code>size</code>维度的矩阵，默认抽取方式为有放回抽样和均匀采样</li></ul><p>具体例子就不写了，记一些课件中的特殊用法吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 对于服从区间 a 到 b 上的均匀分布可以如下生成：</span></span><br><span class="line">a, b = <span class="number">5</span>, <span class="number">15</span></span><br><span class="line">(b - a) * np.random.rand(<span class="number">3</span>) + a</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([ <span class="number">9.67438882</span>, <span class="number">12.49445466</span>,  <span class="number">6.51381903</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 对于服从方差为 σ2 均值为 μ 的一元正态分布可以如下生成：</span></span><br><span class="line">sigma, mu = <span class="number">2.5</span>, <span class="number">3</span></span><br><span class="line">mu + np.random.randn(<span class="number">3</span>) * sigma</span><br><span class="line"><span class="comment">## 结果如下</span></span><br><span class="line">array([<span class="number">5.89540275</span>, <span class="number">2.56563403</span>, <span class="number">1.56208693</span>])</span><br></pre></td></tr></table></figure><h4 id="2-np数组的变形与合并"><a href="#2-np数组的变形与合并" class="headerlink" title="2.np数组的变形与合并"></a>2.np数组的变形与合并</h4><p><strong>转置</strong>：<code>T</code>，<code>np对象.T</code>就可以得到一个转置后的矩阵</p><p><strong>合并</strong>：<code>r_</code>和<code>c_</code>，分别表示左右合并和上下合并，从例子中更容易理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">np.r_[np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]),np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])]</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="comment">## 这里有一点需要注意的是，一维向量合并后还是一维向量，比如[1,2,3]和[1,2,3]合并后是[1,2,3,1,2,3]</span></span><br><span class="line"></span><br><span class="line">np.c_[np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]),np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])]</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment">## 当一维数组和二维数组进行合并时，应当把其视作列向量，只能使用c_操作，并且需要长度匹配</span></span><br></pre></td></tr></table></figure><p><strong>维度变换</strong>：<code>reshape</code>，通过该函数可以指定维度将矩阵进行重新排列，在使用时有两种模式，分别为 <code>C</code> 模式和 <code>F</code> 模式，分别以逐行和逐列的顺序进行填充读取。下面给出课件中的例子方便理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">63</span>]: target = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: target</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: target.reshape((<span class="number">4</span>,<span class="number">2</span>), order=<span class="string">'C'</span>) <span class="comment"># 按照行读取和填充</span></span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: target.reshape((<span class="number">4</span>,<span class="number">2</span>), order=<span class="string">'F'</span>) <span class="comment"># 按照列读取和填充</span></span><br><span class="line">Out[<span class="number">66</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">7</span>]])</span><br></pre></td></tr></table></figure><p><code>reshape</code>函数的一个有意思的点是可以指定维度为-1，代表空缺该维度，个人理解这是什么意思呢，还是通过举例子来说明吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 当要求变换reshape(-1,n)时候，意思是将矩阵列给固定下来，变换后的矩阵为n列，行则由数据多少决定</span></span><br><span class="line"><span class="comment">## 同理，当要求变换成reshape(m,-1)时，则固定矩阵的行为m，列则由数据多少决定</span></span><br></pre></td></tr></table></figure><h4 id="3-数组的索引与切片"><a href="#3-数组的索引与切片" class="headerlink" title="3.数组的索引与切片"></a>3.数组的索引与切片</h4><p>数组的切片模式支持使用 <code>slice</code> 类型的 <code>start:end:step</code> 切片，还可以直接传入列表指定某个维度的索引进行切片，具体例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">target = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line"></span><br><span class="line">target[:, [<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure><p> <code>np.ix_(array1,array2)</code> 在对应的维度上使用布尔索引或者列表索引，原理是根据两个数组生成的笛卡尔积去原数组中找到对应元素后进行排列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">target[np.ix_([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>], [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])]</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>]])</span><br><span class="line"><span class="comment">## 上述结果选取了(0,0)(0,2)等，依据是与运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 当数组维度为1维时，可以直接进行布尔索引，而无需 np.ix_</span></span><br></pre></td></tr></table></figure><h4 id="4-常用函数"><a href="#4-常用函数" class="headerlink" title="4.常用函数"></a>4.常用函数</h4><p>同样地，这里也将写成工具集的形式，后续有其他好用的函数也会添加进来：</p><ul><li><code>where</code>：np.where(a&gt;0, a, 5) ，对应位置为True时填充a对应元素，否则填充5</li><li><code>nonzero(a)</code>：返回<code>a</code>中非零数的索引</li><li><code>a.argmax()</code>：返回<code>a</code>中最大值的索引</li><li><code>a.min()</code>：返回<code>a</code>中最小值的索引</li><li><code>a.any()</code>：当<code>a</code>中至少存在一个True或者非零元素时返回<code>True</code>，否则返回<code>False</code></li><li><code>a.all()</code>：当<code>a</code>中元素全为True或者非零元素时返回<code>True</code>，否则返<code>False</code></li><li><code>a.cumprod()</code>：累乘<code>a</code>中的元素函数，返回相同长度的数组</li><li><code>a.cumsum()</code>：累加<code>a</code>中的元素函数，返回相同长度的数组</li><li><code>a.diff()</code>：<code>a</code>中每个元素和前一个元素做差，返回的长度是原数组长度减一，因为第一个元素没有前一个元素做差</li></ul><p>下面记录一些统计函数：</p><ul><li><code>a.max()</code>：最大值</li><li><code>a.min()</code>：最小值</li><li><code>a.mean()</code>：均值</li><li><code>a.median()</code>：中位数</li><li><code>a.var()</code>：方差</li><li><code>a.sum()</code>：求和</li><li><code>a.max()</code>：最大值</li><li><code>np.quantile (a,0.5)</code>：<code>a</code>的0.5分位数</li><li><code>np.cov(array1, array2)</code>：计算协方差</li><li><code>a.max()</code>：最大值</li></ul><p>对于有缺失值的数组，使用上述统计函数返回的结果也为缺失值，如果需要略过缺失值，则需要使用<code>nan*</code>，比如<code>a.nanmax()</code></p><h4 id="5-广播机制"><a href="#5-广播机制" class="headerlink" title="5.广播机制"></a>5.广播机制</h4><p>广播机制用于处理两个不同维度数组之间的操作</p><p>当一个标量和数组进行运算时，标量会自动把大小扩充为数组大小，之后进行逐元素操作</p><p>当二维数组<code>a</code>和<code>b</code>进行操作时，两个数组维度完全一致时，对应元素进行相关操作，维度不一致时报错。但是，当其中每个数组是<code>m×1</code> 或者 <code>1×n</code>时，把<code>1这个维度</code>扩充到另一个数组对应维度大小后进行计算，下面给出课件中的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">112</span>]: res = np.ones((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: res</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: res * np.array([[<span class="number">2</span>,<span class="number">3</span>]]) <span class="comment"># 扩充第一维度为3</span></span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">array([[<span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">3.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: res * np.array([[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>]]) <span class="comment"># 扩充第二维度为2</span></span><br><span class="line">Out[<span class="number">115</span>]: </span><br><span class="line">array([[<span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: res * np.array([[<span class="number">2</span>]]) <span class="comment"># 等价于两次扩充</span></span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">array([[<span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>]])</span><br></pre></td></tr></table></figure><blockquote><p>当一维数组和二维数组进行操作时，一维数组等价的看成是1行n列</p></blockquote><h4 id="6-向量与矩阵的计算"><a href="#6-向量与矩阵的计算" class="headerlink" title="6.向量与矩阵的计算"></a>6.向量与矩阵的计算</h4><ul><li><code>a.dot(b)</code>：<code>a</code>和<code>b</code>向量做内积运算</li><li><code>a@b</code>：矩阵<code>a</code>和矩阵<code>b</code>做乘法</li></ul><p>向量范数和矩阵范数： <code>np.linalg.nor(矩阵，ord)</code>，ord可选值如下</p><table><thead><tr><th align="left">ord</th><th align="left">norm for matrices</th><th align="left">norm for vectors</th></tr></thead><tbody><tr><td align="left">None</td><td align="left">Frobenius norm</td><td align="left">2-norm</td></tr><tr><td align="left">‘fro’</td><td align="left">Frobenius norm</td><td align="left">–</td></tr><tr><td align="left">‘nuc’</td><td align="left">nuclear norm</td><td align="left">–</td></tr><tr><td align="left">inf</td><td align="left">max(sum(abs(x), axis=1))</td><td align="left">max(abs(x))</td></tr><tr><td align="left">-inf</td><td align="left">min(sum(abs(x), axis=1))</td><td align="left">min(abs(x))</td></tr><tr><td align="left">0</td><td align="left">–</td><td align="left">sum(x != 0)</td></tr><tr><td align="left">1</td><td align="left">max(sum(abs(x), axis=0))</td><td align="left">as below</td></tr><tr><td align="left">-1</td><td align="left">min(sum(abs(x), axis=0))</td><td align="left">as below</td></tr><tr><td align="left">2</td><td align="left">2-norm (largest sing. value)</td><td align="left">as below</td></tr><tr><td align="left">-2</td><td align="left">smallest singular value</td><td align="left">as below</td></tr><tr><td align="left">other</td><td align="left">–</td><td align="left">sum(abs(x)<strong>ord)</strong>(1./ord)</td></tr></tbody></table><h2 id="三、课后习题"><a href="#三、课后习题" class="headerlink" title="三、课后习题"></a>三、课后习题</h2><h4 id="EX1：利用列表推导式写矩阵乘法"><a href="#EX1：利用列表推导式写矩阵乘法" class="headerlink" title="EX1：利用列表推导式写矩阵乘法"></a>EX1：利用列表推导式写矩阵乘法</h4><p>一般的矩阵乘法根据公式，可以由三重循环写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">138</span>]: M1 = np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: M2 = np.random.rand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: res = np.empty((M1.shape[<span class="number">0</span>],M2.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">In [<span class="number">141</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(M1.shape[<span class="number">0</span>]):</span><br><span class="line">   .....:     <span class="keyword">for</span> j <span class="keyword">in</span> range(M2.shape[<span class="number">1</span>]):</span><br><span class="line">   .....:         item = <span class="number">0</span></span><br><span class="line">   .....:         <span class="keyword">for</span> k <span class="keyword">in</span> range(M1.shape[<span class="number">1</span>]):</span><br><span class="line">   .....:             item += M1[i][k] * M2[k][j]</span><br><span class="line">   .....:         res[i][j] = item</span><br><span class="line">   .....: </span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: (np.abs(M1@M2 - res) &lt; <span class="number">1e-15</span>).all() <span class="comment"># 排除数值误差</span></span><br><span class="line">Out[<span class="number">142</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>请将其改写为列表推导式的形式。</p><p>解题如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">M1 = np.random.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">M2 = np.random.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">res = np.empty((M1.shape[<span class="number">0</span>], M2.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">res = [[sum(M1[i][k] * M2[k][j] <span class="keyword">for</span> k <span class="keyword">in</span> range(M1.shape[<span class="number">1</span>])) <span class="keyword">for</span> j <span class="keyword">in</span> range(M2.shape[<span class="number">1</span>])] <span class="keyword">for</span> i <span class="keyword">in</span> range(M1.shape[<span class="number">0</span>])]</span><br><span class="line"><span class="comment"># ans = [matrix_func(i, j, k) for i in range(M1.shape[0]) for j in range(M2.shape[1]) for k in range(M1.shape[1])]</span></span><br><span class="line"></span><br><span class="line">print(np.abs((M1@M2 - res) &lt; <span class="number">1e-15</span>).all())</span><br></pre></td></tr></table></figure><blockquote><p>这题最开始想用一个函数加上列表推导式完成，结果弄了半天发现好像并不行，看了答案和视频讲解后理解了一些大佬的做法和列表推导式的使用技巧，上述结果就是参考答案。说说自己的理解，首先观察矩阵乘法得到的是一个二维数组，既然是二维的，那框架应该是[ [ ] ]，最外层是i循环[ [ ] for i in range(M1.shape[0])]，内层还有两重循环，最内层k循环需要累加使用sum()函数，再加上j循环。其实关键是怎么分离循环，这点需要加强，切记。</p></blockquote><h4 id="Ex2：更新矩阵"><a href="#Ex2：更新矩阵" class="headerlink" title="Ex2：更新矩阵"></a>Ex2：更新矩阵</h4><p>设矩阵$ A_{m\times n}$ ，现在对 A 中的每一个元素进行更新生成矩阵 B ，更新方法是 $\displaystyle B_{ij}=A_{ij}\sum_{k=1}^n\frac{1}{A_{ik}}$ ，例如下面的矩阵为 A ，则$ B_{2,2}=5\times(\frac{1}{4}+\frac{1}{5}+\frac{1}{6})=\frac{37}{12}$ ，请利用 <code>Numpy</code> 高效实现。</p><p>$\begin{split}A=\left[ \begin{matrix} 1 &amp; 2 &amp;3\4&amp;5&amp;6\7&amp;8&amp;9 \end{matrix} \right]\end{split}$</p><p>解题如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">1</span>,<span class="number">10</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">C = np.sum(<span class="number">1</span>/A, axis = <span class="number">1</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">B = A*C</span><br></pre></td></tr></table></figure><blockquote><p>参考答案是A*(1/A).sum(1).reshape(-1,1)</p><p>看答案之后才知道原来可以直接对np对象使用sum()函数</p></blockquote><h4 id="Ex3：卡方统计量"><a href="#Ex3：卡方统计量" class="headerlink" title="Ex3：卡方统计量"></a>Ex3：卡方统计量</h4><p>设矩阵$ A_{m\times n}$ ，记 $B_{ij} = \frac{(\sum_{i=1}^mA_{ij})\times (\sum_{j=1}^nA_{ij})}{\sum_{i=1}^m\sum_{j=1}^nA_{ij}} $，定义卡方值如下：</p><p>$\chi^2 = \sum_{i=1}^m\sum_{j=1}^n\frac{(A_{ij}-B_{ij})^2}{B_{ij}}$</p><p>请利用 <code>Numpy</code> 对给定的矩阵 A 计算$ \chi^2 $。</p><p>解题如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.rand(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">A_m = np.sum(A, axis = <span class="number">0</span>)</span><br><span class="line">A_n = np.sum(A, axis = <span class="number">1</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">B = (A_m * A_n) / np.sum(A)</span><br><span class="line">X = np.sum((A - B)*(A-B)/B)</span><br></pre></td></tr></table></figure><h4 id="Ex4：改进矩阵计算的性能"><a href="#Ex4：改进矩阵计算的性能" class="headerlink" title="Ex4：改进矩阵计算的性能"></a>Ex4：改进矩阵计算的性能</h4><p>设$ Z$ 为 $m\times n $的矩阵， $B$ 和$ U$ 分别是 $m\times p$ 和$ p\times n$ 的矩阵， $B_i $为 B 的第 i 行，$ U_j$ 为 $U $的第 $j $列，下面定义 $\displaystyle R=\sum_{i=1}^m\sum_{j=1}^n|B_i-U_j|<em>2^2Z</em>{ij} $，其中$ |\mathbf{a}|_2^2 $表示向量$ \mathbf{a} $的分量平方和$ \sum_i a_i^2$ 。</p><p>现有某人根据如下给定的样例数据计算 R 的值，请充分利用 <code>Numpy</code> 中的函数，基于此问题改进这段代码的性能。</p><p>解题如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">m, n, p = <span class="number">100</span>, <span class="number">80</span>, <span class="number">50</span></span><br><span class="line">B = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, (m, p))</span><br><span class="line">U = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, (p, n))</span><br><span class="line">Z = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, (m, n))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误解答：(((B.sum(1).reshape(-1, 1) - U.sum(0))**2)*Z).sum()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参考答案</span></span><br><span class="line">(((B**<span class="number">2</span>).sum(<span class="number">1</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>) + (U**<span class="number">2</span>).sum(<span class="number">0</span>) - <span class="number">2</span>*B@U)*Z).sum()</span><br></pre></td></tr></table></figure><blockquote><p>这题有些天真了，看了答案后发现主要问题在于没有把B - U这个转换做好</p><p>还有需要注意的一点是直接用np对象做sum的话，不管指定沿着哪个维度累加，最后都会变成一行N列的向量</p></blockquote><h4 id="Ex5：连续整数的最大长度"><a href="#Ex5：连续整数的最大长度" class="headerlink" title="Ex5：连续整数的最大长度"></a>Ex5：连续整数的最大长度</h4><p>输入一个整数的 <code>Numpy</code> 数组，返回其中递增连续整数子数组的最大长度。例如，输入 [1,2,5,6,7]，[5,6,7]为具有最大长度的递增连续整数子数组，因此输出3；输入[3,2,1,2,3,4,6]，[1,2,3,4]为具有最大长度的递增连续整数子数组，因此输出4。请充分利用 <code>Numpy</code> 的内置函数完成。（提示：考虑使用 <code>nonzero, diff</code> 函数）</p><p>解答如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考答案</span></span><br><span class="line">np.diff(np.nonzero(np.r_[<span class="number">1</span>,np.diff(a)!=<span class="number">1</span>,<span class="number">1</span>])).max()</span><br></pre></td></tr></table></figure><blockquote><p>这题用np的内置函数完成确实没想到，在leetcode上好像刷过这个题（不用numpy的话用两个指针探测最大长度应该是可行的），总结一下大佬给的参考答案的思路吧</p><p>首先利用diff函数得到相减后的数组，并且利用布尔索引将数组转换为相邻数值间差不为1的值设置为1，相邻数值间差为1的设置为0，为nonzero函数做准备，这里需要注意的是，前后要补1，因为最开始这个数没有数字减，最后一个数没有数减它，把[1,2,3,4]作为例子代入也能明白为什么要补1</p><p>接着用nonzero函数得到不为0的索引值数组，比如[2,5]那么就代表了索引2和5中间的数字是连续的</p><p>最后再利用diff函数做一次差值就能得到原始数组中各个整数连续段所包含的整数个数</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>人太懒，好久没写过博客了，第一次参加<code>datawhale</code>的组队学习活动，因为之前主要还是做<code>java</code>，对<code>python</code>了解一些但也不是特别熟悉，学习起来还是有些吃力，特别是最后的习题也花了蛮久的时间，还是半看答案半做才做完。虽然困难重重，花了大概一整天的时间，但也算是完成了第一次作业，可喜可贺，希望能继续坚持下去，也希望能把坚持写博客的习惯养成，不要三天打鱼两天晒网。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、python基础&quot;&gt;&lt;a href=&quot;#一、python基础&quot; class=&quot;headerlink&quot; title=&quot;一、python基础&quot;&gt;&lt;/a&gt;一、python基础&lt;/h2&gt;&lt;p&gt;下面的python基础涉及python的基本数据结构等知识，本来想着在这里补充上的，试了一下发现并没有网上一些教程写的好，本着不重复造轮子的想法（其实就是懒）也就不加了，如果需要的话可参考廖雪峰的python教程&lt;/p&gt;
&lt;h3 id=&quot;1、列表推导式和条件赋值&quot;&gt;&lt;a href=&quot;#1、列表推导式和条件赋值&quot; class=&quot;headerlink&quot; title=&quot;1、列表推导式和条件赋值&quot;&gt;&lt;/a&gt;1、列表推导式和条件赋值&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;列表推导式&lt;/strong&gt;：按照一定的语法帮助简化操作，可以较容易的获取一个列表，语法为&lt;code&gt;[A for i in B]&lt;/code&gt;，其中&lt;code&gt;A&lt;/code&gt;为函数名（需要注意的是别忘了要带参数比如：&lt;code&gt;A(i)&lt;/code&gt;），&lt;code&gt;B&lt;/code&gt;是一个迭代的对象。具体例子如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;my_func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x * x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[myfunc(i) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 结果如下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 列表表达式还可以进行多层嵌套&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[x + y &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; y &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 结果如下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 个人理解：多层嵌套下相当于多重for循环，这个结果也验证了这个想法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="datawhale" scheme="http://yoursite.com/tags/datawhale/"/>
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型及垃圾回收器</title>
    <link href="http://yoursite.com/2020/10/27/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2020/10/27/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2020-10-27T05:33:19.000Z</published>
    <updated>2020-11-24T03:17:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>JVM内存模型可划分为五个区域：程序计数器、本地方法区、虚拟机栈、Java堆、方法区。如下图所示：</p><p><img src="http://png.xiaolei.cool/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JVM内存模型"></p><p>这五个区域又可分为两大类：<strong>线程私有</strong>、<strong>线程共享</strong>。其中程序计数器、本地方法区、虚拟机栈是线程私有的，Java堆是线程共享的，下面具体聊聊这五个区域的作用。</p><a id="more"></a><p><strong>程序计数器</strong>：线程所执行字节码的行号指示器，可以通过改变这个计数器的值来选取下一条需要执行的指令。为了防止线程切换后能够准确的还原上一次所执行的位置，每一个线程都需要有自己的程序计数器，这也能明白为什么程序计数器是线程私有的了（注：Native方法执行的时计数器的值为空）</p><p><strong>Java虚拟机栈</strong>：描述Java方法执行的线程内存模型，每个方法在执行的时候JVM都会创建一个栈祯用于存储局部变量表、操作数栈、动态连接、方法出口等信息。其中局部变量表存放了Java的基本数据类型、对象引用和returnAddress（指向一条字节码地址）。从存储局部变量这点就不难看出，这也是线程私有的。</p><p><strong>本地方法栈</strong>：顾名思义，这是为虚拟机使用Native方法提供服务的区域，也是线程私有的。</p><p>说完了线程私有的三个区域，那剩下两个就是线程共享的了</p><p><strong>Java堆</strong>：存放对象实例，是垃圾回收器管理的内存区域。在实际调优中，可以通过<code>-Xmx</code>和<code>-Xms</code>来指定堆内存的最大值和初始值，通常将两者设置成相同大小，这样做可以避免堆内存扩容所带来的性能开销，但具体情况还应该具体分析。</p><p><strong>方法区</strong>：存储已被JVM加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>上面就是JVM内存模型中主要的五个区域，其实还有两个内存区域是没有被提及的，一个是用来存储运行时产生的常量的<strong>运行时常量池</strong>；另一个是直接内存区域，这一区域属于堆外内存，与Native方法配合存放虚拟机之外对象的引用。</p><p>ok，知道了JVM内存区域之后，我们讲讲垃圾回收算法以及垃圾回收期，也就是在Java堆中发生了什么。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>在讲垃圾回收算法之前应该讲讲怎么样将对象定义为垃圾。大体上是有两种方式的：</p><ul><li>引用计数法：记录一个对象被引用的次数，当该次数为0的话则代表这个对象是一个垃圾，可以被回收。</li><li>根可达算法：通过<code>GC Root</code>向下索引，只要是能索引到的都不是垃圾，剩下的没有被索引到的对象就是垃圾了。固定作为<code>GC Root</code>的对象 包含以下几种：<ul><li>在虚拟机栈中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li><li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</li><li>在方法区中常量引用的对象，譬如字符串常量池里的引用</li><li>Java虚拟机内部的引用，如基本数据类型对用的Class对象，一些常驻的异常对象等，还有系统类加载器</li><li>所有被同步锁持有的对象</li><li>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul></li></ul><blockquote><p>引用计数法可能会造成内存泄漏，例如A对象和B对象都有相同类型的数据，A对象的该属性指向了B对象，B对象的该属性指向了A对象，除此之外再无别的对象指向这两个对象。根据引用计数法将判断这两个对象都是存在引用的，因此不会认为是垃圾，但是实际上却是这两个对象没可能再用了。</p></blockquote><p>目前商用的大多数垃圾回收器都采用了分代回收策略——将堆内存分为年轻代（Young）和老年代（Old），默认比例是1：2（可通过参数调整）。</p><ul><li>新生代存储的是刚分配的对象和分配不久的对象。</li><li>老年代存储的是新生代放不下的大对象或者是经过多次垃圾回收依然存活的新生代对象。</li></ul><p>针对不同的区域，适配了不同的算法，主要有以下三类：</p><p><strong>标记—复制算法</strong>：这一算法通常作用于新生代。首先是标记出存活的对象，然后将存活对象复制到空闲区，再将非空闲区全部清除。ok，那这里就涉及到空闲区和非空闲区的划分了，这一划分还是很有讲究的，因为可用的空间就是非空闲区，如果划分的不合理的话那就造成了可用的内存很小的情况，根据IBM的调查研究发现，90%对象都是朝生夕死。根据这一理论将区域划分Eden区、From区、To区，当一个对象创建时会在Eden区开辟一段内存，当Eden区满了触发垃圾回收，会将存活对象放入From区并清空其他区域，下一次触发垃圾回收时会将存活对象放入To区并清空其他区域，如下图所示</p><p><img src="http://png.xiaolei.cool/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="标记复制"></p><p>默认Eden：From：To是8：1：1（可调整），但是不管怎么调整，使用标记复制算法一定是会有一部分内存空间无法正常使用，这也是标记复制算法的缺点之一。</p><p><strong>标记—清除算法</strong>：将存活对象标记出，直接清除其他对象，如下图所示。这一算法的优点是效率高，但是缺点也十分明显，比如会产生大量的内存碎片，比如当一个对象创建时如果没有一片连续的空间可分配，那就会直接进入老年代，但其实新生代中还有空闲内存。</p><p><img src="http://png.xiaolei.cool/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95" alt="标记清除"></p><p><strong>标记整理算法</strong>：标记处存活对象，将其余对象清除后将存活对象整理至一片连续内存当中，如下图所示。虽然这一算法看起来即实现了垃圾回收，又解决了内存碎片问题，</p><p><img src="http://png.xiaolei.cool/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95" alt="标记整理"></p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="串行回收器"><a href="#串行回收器" class="headerlink" title="串行回收器"></a>串行回收器</h3><p>串行回收器Serial是最早出现的垃圾回收器，分为新生代和老年代两个版本。它的作用机理是开启一个线程进行垃圾回收，在开启线程的同时会暂停用户线程，等待垃圾回收线程工作完后再重新开启，这也就是著名的<code>Stop The World（STW）</code></p><p>虽然Serial是第一个出现的垃圾回收器并且还存在让用户体验非常不好的STW，但是需要说明的是它仍然有它的用途。事实上它依然是客户端模式下虚拟机的默认的新生代收集器，相比如其他收集器来说，它简单而高效（与其他收集器单线程相比），这点在资源受限的环境下尤为明显。对于单核处理器获处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p><strong>相关调优参数</strong>：</p><ul><li><code>-XX:+UseSerialGC</code>：在新生代和老年代使用Serial回收器</li><li><code>-XX:PretenureSizeThreshold=1000000</code>：将1MB以上的对象分配进老年代</li><li><code>-XX:MaxTenuringThreshold=15</code>：将超过15岁的对象移入老年代</li></ul><h3 id="并行回收器"><a href="#并行回收器" class="headerlink" title="并行回收器"></a>并行回收器</h3><p>目前商用的并行回收器主要是<code>ParNew</code>和<code>Parallel SCavenge</code>两种</p><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p><code>ParNew</code>收集器只工作在新生代中，和<code>Serial</code>收集器相比只是它的多线程并行版本，除了同时用多条线程进行垃圾回收之外，其余行为包括<code>Serial</code>的所有可控制参数、收集器算法、Stop The World、对象分配策略、回收策略等都是一致的。<code>ParNew</code>收集器是在JDK 7之前遗留系统中首选的新生代回收器，原因是除了<code>Serial</code>回收器外，只有它能和CMS回收器进行配合。</p><p><code>ParNew</code>在单核心处理器环境中不会有比<code>Serial</code>有更好的效果，甚至由于存在线程的开销，在超线程技术实现的伪双核处理器环境中都不能百分之百超越<code>Serial</code>，当然随着核心线程数增加<code>ParNew</code>的性能也将随之提升，默认情况下<code>ParNew</code>将开启和核心线程数量相同的垃圾回收线程</p><p><strong>相关调优参数</strong>：</p><ul><li><code>-XX:+UseParNewGC</code>：使用<code>ParNew</code>作为新生代的垃圾回收器</li><li><code>-XX:ParallelGCThreads=20</code>：开启20个线程进行垃圾回收</li></ul><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p><code>Parallel scavenge</code>回收器与<code>ParNew</code>回收器有许多相似之处，不同的是<code>Parallel Scavenge</code>关注点在系统的吞吐量上，所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即：<br>$$<br>吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}<br>$$<br>比如虚拟机完成某个任务需要100分钟，其中99分钟都用来运行用户代码了，1分钟进行垃圾回收，那么此时的吞吐量就是99%</p><p><code>Parallel Scavenge</code>分为新生代和老年代两个版本，新生代使用标记复制算法，老年代使用标记整理算法</p><p>如果新生代选择了<code>Parallel Scavenge</code>收集器，那么老年代就要选择<code>Serial Old</code>收集器</p><p><strong>相关调优参数</strong>：</p><ul><li><code>-XX:UseParallelGC</code>：指定新生代使用并行回收器</li><li><code>-XX:UseParallelOldGC</code>：指定老年代使用并行回收器</li><li><code>-XX:MaxGCPauseMillis=200</code>：指定收集器尽可能在200ms内完成垃圾回收</li><li><code>-XX:GCTimeRatio=99</code>:指定收集器的吞吐量为99%</li></ul><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p> <code>CMS</code>使用的是标记清除算法，工作在老年代。称得上是一款划时代的垃圾回收器，因为不同于之前所有的垃圾回收器用户线程和垃圾回收线程总是不同时工作，<code>CMS</code>实现了并发垃圾回收。它的工作流程分为以下几步：</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p>初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记以下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾回收线程一起并发运行；而重新标记阶段则是为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。流程图如下：</p><p><img src="http://png.xiaolei.cool/CMS.png" alt="CMS"></p><p>虽然<code>CMS</code>是一款优秀的处理器，但是它仍然有几个明显的缺点：</p><ol><li><code>CMS</code>对资源十分敏感，在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。<code>CMS</code>默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾回收线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，<code>CMS</code>对用户程序的影响就可能变得很大。</li><li><code>CMS</code>无法处理浮动垃圾。由于并发标记阶段和并发清理阶段用户线程还在运行，因此仍然会产生垃圾，这部分就称为浮动垃圾，<code>CMS</code>处理器无法在当次垃圾回收时处理它。只能留给下一次垃圾回收。另外就是由于<code>CMS</code>垃圾回收线程和用户线程并发执行，所以必须预留足够的空间给用户线程执行，因此无法在老年代填满时进行垃圾回收，<code>JDK 5</code>时默认是68%，到了<code>JDK 6</code>这一阈值提升至了92%，也可以通过<code>-XX:CMSInitiatingOccu-pancyFraction</code>来自定义。但是这也流下了另一种隐患，如果预留空间的值无法满足程序分配新对象的需要，就会出现并发失败，这时候虚拟机不得不启动预案：冻结用户线程的执行，临时启用<code>Serial Old</code>收集器来进行垃圾回收。但这样停顿的时间就很长了，因此阈值的设定也不能设置的过高，应根据实际生产活动中来权衡。</li><li><code>CMS</code>由于使用了<code>标记——清除</code>算法，因此会产生大量的内存碎片，当无法找到足够大的连续空间来分配对象时就会触发一次<code>Full GC</code></li></ol><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p><code>G1</code>垃圾回收器是垃圾收集器发展历史上里程碑式的成果， 它开创了收集器面向局部收集的设计思路和基于<code>Region</code>的内存布局形式。<code>G1</code>收集器虽然仍是遵循分代收集理论设计的，但<code>G1</code>不再坚持固定大小及数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域， 每一个<code>Region</code>都可以根据需要，扮演新生代的<code>Eden</code>、<code>Survivor</code>空间或者是老年代空间。收集器能够对扮演不同角色的<code>Region</code>采用不同的策略去处理，这样无论是新创建的对象还是已经存活一段时间的旧对象都能获得很好的收集效果。</p><p><code>Region</code>中还有一类特殊的<code>Humongous</code>区域，专门存储大对象，一般大小超过<code>Region</code>区域一半的对象都会被认为是大对象，如果一个对象超过了单个<code>Region</code>区域大小，那么会将该对象存储到多个连续的<code>Humongous Region</code>区域中。</p><p><code>G1</code>基于的是一种建立<code>停顿时间模型</code>的思想，目的是把垃圾回收控制在一个精确的时间内，而<code>Region</code>区域划分则帮助了<code>G1</code>实现这个目的，因为垃圾回收器可以评估在当前设置的时间内回收哪个<code>Region</code>区域的收益最大，进而进行回收。</p><p><strong>相关调优参数</strong>：</p><ul><li><code>-XX:G1HeapRegionSize</code>：设置<code>Region</code>的大小</li><li><code>-XX:MaxGCPauseMillis</code>：设定允许的收集停顿时间，默认值是200ms</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h3&gt;&lt;p&gt;JVM内存模型可划分为五个区域：程序计数器、本地方法区、虚拟机栈、Java堆、方法区。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://png.xiaolei.cool/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png&quot; alt=&quot;JVM内存模型&quot;&gt;&lt;/p&gt;
&lt;p&gt;这五个区域又可分为两大类：&lt;strong&gt;线程私有&lt;/strong&gt;、&lt;strong&gt;线程共享&lt;/strong&gt;。其中程序计数器、本地方法区、虚拟机栈是线程私有的，Java堆是线程共享的，下面具体聊聊这五个区域的作用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow2搭建神经网络及其扩展</title>
    <link href="http://yoursite.com/2020/10/22/TensorFlow2%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2020/10/22/TensorFlow2%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/</id>
    <published>2020-10-22T15:09:08.000Z</published>
    <updated>2020-10-22T15:12:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>tensorflow笔记系列文章均参考自中国大学Mooc上北京大学软件与微电子学院曹建老师的《Tensorflow笔记2》课程。曹建老师讲的非常棒，受益良多，强烈建议tensorflow初学者学习。</p></blockquote><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><p>使用keras搭建神经网络通常有以下六步：</p><ul><li>import 相关模块</li><li>train, test 说明训练集和测试集</li><li>model = tf.keras.models.Sequential 搭建网络结构，逐层描述每层网络</li><li>model.compile 配置训练方法，例如优化器、损失函数、评测指标</li><li>model.fit 执行训练过程</li><li>model.summary 打印出网络的结构和参数统计</li></ul><a id="more"></a><h3 id="Sequential-用法"><a href="#Sequential-用法" class="headerlink" title="Sequential()用法"></a>Sequential()用法</h3><p><code>Sequential()</code>可以认为是一个容器，里面封装了一个神经网络的结构，在<code>Sequential()</code>要描述从输入层到输出层每一层的网络结构，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = tf.keras.models.Sequential([网络结构])</span><br></pre></td></tr></table></figure><p>网络结构举例：</p><p><strong>拉直层</strong>：<code>tf.keras.layers.Flatten()</code>，这一层不含计算，只是将输入数据拉直变成一维数组</p><p><strong>全连接层</strong>：<code>tf.kears.layers.Dense(神经元个数,activation=&quot;激活函数&quot;,kernel_regularizer=哪种正则化)</code>，其中激活函数可选:<strong>relu、softmax、sigmoid、tanh</strong>，正则化可选：<strong>tf.kears.regularizers.l1()、tf.keras.regularizers.l2()</strong></p><p><strong>卷积层</strong>：<code>tf.keras.layers.Conv2D(filters=卷积核个数,kernel_size=卷积核尺寸，strides=卷积步长，padding=&quot;valid&quot;或者&quot;same&quot;)</code></p><p><strong>LSTM层</strong>：tf.keras.layers.LSTM()</p><h3 id="compile-用法"><a href="#compile-用法" class="headerlink" title="compile()用法"></a>compile()用法</h3><p>compile指定网络的优化器、损失函数以及评测指标，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=优化器，loss=损失函数, metrics=[<span class="string">"准确率"</span>])</span><br></pre></td></tr></table></figure><p><strong>Optimizer可选</strong>：</p><ul><li>‘sgd’ or tf.keras.optimizer.SGD(lr=学习率，momentum=动量参数)</li><li>‘adagrad’ or tf.keras.optimizers.Adagrad(lr=学习率)</li><li>‘adadelta’ or tf.kears.optimizers.Adadelta(lr=学习率)</li><li>‘adam’ or tf.keras.optimizers.Adam(lr=学习率，beta_1=0.9，beta_2=0.999)</li></ul><p><strong>loss可选</strong>：</p><ul><li>‘mse’ or tf.keras.losses.MeanSquaredError()</li><li>‘sparse_categorical_crossentropy’ or tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False)，需要注意的是from_logits这个参数代表输出时是否符合概率分布，如果不符合概率分布，那么为true，否则为false</li></ul><p><strong>Metrics可选</strong>：</p><ul><li>‘accuracy’ : y_和y都是数值，如y__=[1]  y=[1]</li><li>‘categorical_accuracy’ : y_和y都是独热码形式</li><li>‘sparse_categorical_accuracy’ : y_是数值，y是独热码</li></ul><h3 id="fit-用法"><a href="#fit-用法" class="headerlink" title="fit()用法"></a>fit()用法</h3><p><code>fit()</code>函数描述训练的的过程，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model.fit(训练集的输入特征，训练集的标签，</span><br><span class="line">         batch_size= , epochs= , </span><br><span class="line">         validation_data=(测试集的输入特征，测试集的标签),</span><br><span class="line">         validation_split=从训练集划分多少比例给测试集，</span><br><span class="line">         validation_freq=多少次epoch测试一次)</span><br></pre></td></tr></table></figure><p> <code>validation_data</code>和`validation_split二者选择其一即可</p><h3 id="keras搭建神经网络实现鸢尾花数据集例子"><a href="#keras搭建神经网络实现鸢尾花数据集例子" class="headerlink" title="keras搭建神经网络实现鸢尾花数据集例子"></a>keras搭建神经网络实现鸢尾花数据集例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import相关模块</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载训练数据</span></span><br><span class="line">x_train = datasets.load_iris().data</span><br><span class="line">y_train = datasets.load_iris().target</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(x_train)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_train)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭载网络结构</span></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">3</span>, activation=<span class="string">"softmax"</span>, kernel_regularizer=tf.keras.regularizers.l2())</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置训练方法</span></span><br><span class="line">model.compile(optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">              metrics=[<span class="string">'sparse_categorical_accuracy'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用fit进行训练</span></span><br><span class="line">model.fit(x_train, y_train, batch_size=<span class="number">32</span>,</span><br><span class="line">          epochs=<span class="number">500</span>, validation_split=<span class="number">0.2</span>,</span><br><span class="line">          validation_freq=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Summary函数打印玩那个罗的结构和参数统计</span></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><hr><h3 id="用类搭建神经网络结构"><a href="#用类搭建神经网络结构" class="headerlink" title="用类搭建神经网络结构"></a>用类搭建神经网络结构</h3><p>可以将神经网络结构封装到一个类中，语法如下表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span><span class="params">(Model)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyModel, self).__init__()</span><br><span class="line">        <span class="comment"># 定义网络结构块</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 调用网络结构块，实现前向传播</span></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">model = MyModel()</span><br></pre></td></tr></table></figure><p>针对鸢尾花数据集，有如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IrisModel</span><span class="params">(Model)</span>:</span> <span class="comment">#括号里Model代表了继承Model类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(IrirsModel, self).__init__()</span><br><span class="line">        self.d1 = Dense(<span class="number">3</span>, activation=<span class="string">'softmax'</span>, kernel_regularizer=tf.keras.regularizers.l2())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        y = self.d1(X)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">model = IrisModel()</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="自制数据集"><a href="#自制数据集" class="headerlink" title="自制数据集"></a>自制数据集</h3><p>一般来说，<code>tensorflow</code>的<code>keras</code>框架中<code>datasets</code>模块提供的数据集足够我们玩了，但有时我们也需要使用已有数据来制作自己的数据集。下面提供一个<code>generated</code>函数来实现自制数据集的生成，代替<code>load_data()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    :parameter</span></span><br><span class="line"><span class="string">        - path: 数据文件路径</span></span><br><span class="line"><span class="string">        - txt: 数据文件的文本描述，通常由两列组成，第一列表示文件名（和文件路径组合可以得到完整路径），</span></span><br><span class="line"><span class="string">                第二列为这一数据对应的标签值</span></span><br><span class="line"><span class="string">    :returns</span></span><br><span class="line"><span class="string">        - x: 特征值</span></span><br><span class="line"><span class="string">        - y_: 标签值</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateds</span><span class="params">(path, txt)</span>:</span></span><br><span class="line">    f = open(txt, <span class="string">'r'</span>)</span><br><span class="line">    contents = f.readlines()  <span class="comment"># 按行读取</span></span><br><span class="line">    f.close()</span><br><span class="line">    x, y_ = [], []</span><br><span class="line">    <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">        value = content.split()  <span class="comment"># 以空格分开，存入数组</span></span><br><span class="line">        img_path = path + value[<span class="number">0</span>]</span><br><span class="line">        img = Image.open(img_path)</span><br><span class="line">        img = np.array(img.convert(<span class="string">'L'</span>))  <span class="comment"># 转换为灰度图</span></span><br><span class="line">        img = img / <span class="number">255.</span>  <span class="comment"># 归一化数值</span></span><br><span class="line">        x.append(img)</span><br><span class="line">        y_.append(value[<span class="number">1</span>])</span><br><span class="line">        print(<span class="string">'loading : '</span> + content)</span><br><span class="line"></span><br><span class="line">    x = np.array(x)</span><br><span class="line">    y_ = np.array(y_)</span><br><span class="line">    y_ = y_.astype(np.int64)</span><br><span class="line">    <span class="keyword">return</span> x, y_</span><br></pre></td></tr></table></figure><h3 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h3><p>数据增强可以帮助我们增大数据量，<code>tensorflow</code>提供了数据增强方法<code>ImageDataGenerator()</code>，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">image_gen_train = tf.keras.preprocessing.image.ImageDataGenerator(</span><br><span class="line">rescale=所有数据将乘以该数值,</span><br><span class="line">rotation_range=随机旋转角度数范围,</span><br><span class="line">width_shift_range=随机宽度偏移量,</span><br><span class="line">height_shift_range=随机高度偏移量,</span><br><span class="line">水平翻转: horizontal_flip=是否随机水平翻转.</span><br><span class="line">随机缩放: zoom_range=随机缩放的范围[<span class="number">1</span>-n,<span class="number">1</span>+n])</span><br><span class="line">image_gen_train.fit(x_train)</span><br></pre></td></tr></table></figure><p>下面给出一个具体实例： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">image_gen_train = ImageDataGenerator(</span><br><span class="line">rescale=<span class="number">1.</span>/<span class="number">1.</span>,  <span class="comment"># 如为图像，分母为255时，可归至0-1</span></span><br><span class="line">rotation_range=<span class="number">45</span>,  <span class="comment"># 随机45度旋转</span></span><br><span class="line">width_shift_range=<span class="number">.15</span>,  <span class="comment"># 宽度偏移</span></span><br><span class="line">height_shift_range=<span class="number">.15</span>,  <span class="comment"># 高度偏移</span></span><br><span class="line">horizontal_flip=<span class="literal">False</span>,  <span class="comment"># 水平翻转</span></span><br><span class="line">zoom_range=<span class="number">0.5</span>  <span class="comment">#将图像随机随访阈量)</span></span><br><span class="line">image_gen_train.fit(x_train)</span><br></pre></td></tr></table></figure><p>需要注意的是这里的<code>x_train</code>需要是一个四维数据，因此需要对数据进行<code>reshape()</code>，同时<code>model.fit()</code>也需要变为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(image_gen_train.flow(x_train,y_train,batch_size=<span class="number">32</span>),...)</span><br></pre></td></tr></table></figure><h3 id="断点续训"><a href="#断点续训" class="headerlink" title="断点续训"></a>断点续训</h3><p>断点续训分为保存模型和读取模型</p><p><strong>读取模型</strong>的操作可以使用<code>model.load_weight()</code>函数，一般操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">checkpoint_save_path &#x3D; &quot;.&#x2F;checkpoint&#x2F;mnist.ckpt&quot;</span><br><span class="line">if os.path.exists(checkpoint_save_path + &#39;.index&#39;):</span><br><span class="line">print(&quot;-----------load the model-----------&quot;)</span><br><span class="line">model.load_weights(checkpoint_save_path)</span><br></pre></td></tr></table></figure><p><strong>保存模型</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp_callback &#x3D; tf.keras.callbacks.ModelCheckpoint(</span><br><span class="line">filepath&#x3D;路径文件名,</span><br><span class="line">save_weights_only&#x3D;True&#x2F;False,</span><br><span class="line">save_best_only&#x3D;True&#x2F;False</span><br><span class="line">)</span><br><span class="line">history &#x3D; model.fit(callbacks&#x3D;[cp_callback])</span><br></pre></td></tr></table></figure><h3 id="参数提取"><a href="#参数提取" class="headerlink" title="参数提取"></a>参数提取</h3><p><code>model.trainable_variables</code>返回模型中可训练的参数</p><p><strong>设置print输出格式：</strong><code>np.set_printoptions(threshold=超过多少省略显示)</code>，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold=np.inf)</span><br><span class="line">print(model.trainable_variables)</span><br></pre></td></tr></table></figure><p>在<code>model.trainable_variables</code>里有各个参数name值，shape值和numpy()值，可以通过for循环遍历打印出来</p><h3 id="acc-loss可视化"><a href="#acc-loss可视化" class="headerlink" title="acc/loss可视化"></a>acc/loss可视化</h3><p>在前面的<code>model.fit</code>中除了训练模型，还同步记录了训练集<code>loss</code>，测试集<code>val_loss</code>，训练集准确率<code>sparse_categorical_accuracy</code>以及测试集准确率<code>val_sparse_categorical_accuracy</code>，我们在前面的代码中将其存在了<code>histrory</code>中，通过以下方式可以取得：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acc = histrory.histrory[<span class="string">'sparse_categorical_accuracy'</span>]</span><br><span class="line">val_acc = histrory.histrory[<span class="string">'val_sparse_categorical_accuracy'</span>]</span><br><span class="line">loss = histrory.histrory[<span class="string">'loss'</span>]</span><br><span class="line">val_loss = histrory.histrory[<span class="string">'val_loss'</span>]</span><br></pre></td></tr></table></figure><p>用以下代码可以实现画图，将数据可视化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(acc,label=<span class="string">'训练集准确率'</span>)</span><br><span class="line">plt.plot(val_acc,label=<span class="string">'测试集准确率'</span>)</span><br><span class="line">plt.title(<span class="string">'训练集和测试集准确率'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot(loss,label=<span class="string">'训练集损失函数'</span>)</span><br><span class="line">plt.plot(val_loss,label=<span class="string">'测试集损失函数'</span>)</span><br><span class="line">plt.title(<span class="string">'训练集和测试集损失函数'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="前向传播实现应用"><a href="#前向传播实现应用" class="headerlink" title="前向传播实现应用"></a>前向传播实现应用</h3><p>前向传播实现给图识物的应用通常需要三步：</p><ul><li>复现模型：<code>model = tf.keras.models.Sequential([...])</code></li><li>加载参数：<code>model.load_weights(model_save_path)</code></li><li>预测结果：<code>result = model.predict(x_predict)</code></li></ul><p>注意的是，根据训练的模型，要对给出的图片进行一定的修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img = Image.open(image_path)</span><br><span class="line">img = img.resize((<span class="number">28</span>,<span class="number">28</span>), Image.ANTIALIAS)  <span class="comment"># 将图片转换成28行28列的尺寸</span></span><br><span class="line">img_arr = np.arry(img.convert(<span class="string">'L'</span>))  <span class="comment">#  转换为灰度图</span></span><br><span class="line"></span><br><span class="line">img_arr = <span class="number">255</span> - imf_arr  <span class="comment"># 颜色取反，这步根据输入图片和训练图片来决定是否需要</span></span><br><span class="line">img_Arr = img_Arr / <span class="number">255.0</span></span><br><span class="line">x_predict = img_arr[tf.newaxis, ...]  <span class="comment"># 由于训练时候是按照batch送入网络，因此要加一个维度，变为（1，28，28）</span></span><br><span class="line">result = model.predict(x_predict)</span><br><span class="line">pred = tf.argmax(result, axis=<span class="number">1</span>)</span><br><span class="line">tf.print(pred)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;tensorflow笔记系列文章均参考自中国大学Mooc上北京大学软件与微电子学院曹建老师的《Tensorflow笔记2》课程。曹建老师讲的非常棒，受益良多，强烈建议tensorflow初学者学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;搭建流程&quot;&gt;&lt;a href=&quot;#搭建流程&quot; class=&quot;headerlink&quot; title=&quot;搭建流程&quot;&gt;&lt;/a&gt;搭建流程&lt;/h2&gt;&lt;p&gt;使用keras搭建神经网络通常有以下六步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;import 相关模块&lt;/li&gt;
&lt;li&gt;train, test 说明训练集和测试集&lt;/li&gt;
&lt;li&gt;model = tf.keras.models.Sequential 搭建网络结构，逐层描述每层网络&lt;/li&gt;
&lt;li&gt;model.compile 配置训练方法，例如优化器、损失函数、评测指标&lt;/li&gt;
&lt;li&gt;model.fit 执行训练过程&lt;/li&gt;
&lt;li&gt;model.summary 打印出网络的结构和参数统计&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
    <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>kNN算法简介与实现</title>
    <link href="http://yoursite.com/2020/10/17/kNN%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/10/17/kNN%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-10-17T14:32:22.000Z</published>
    <updated>2020-10-17T14:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-kNN算法简介"><a href="#1-kNN算法简介" class="headerlink" title="1.kNN算法简介"></a>1.kNN算法简介</h2><p>kNN的全称K Nearest Neighbors，又称K近邻算法。kNN算法是一种有监督学习的分类算法，原理很简单，甚至我们从名字上就能看出大概（k近邻也就是说找到k个邻居）。下面给出kNN算法的实现步骤：</p><ul><li>1.输入一个待分类数据，确定K值（K值用来确定需要几个“邻居”）</li><li>2.依次计算输入数据和训练数据距离（比如欧氏距离）</li><li>3.将距离从小到大排序，获取前k个距离短的数据</li><li>4.统计这k个数据所属的分类值，输出得分最高的分类作为该待分类数据所属的类别</li></ul><p>从实现步骤上来看很简单，实际上也确实是这样，因此kNN算法被称作最简单的分类算法，但是正是因为原理和实现都很简单kNN算法也成为了最常用的分类算法之一。</p><a id="more"></a><h2 id="2-kNN算法的代码实现"><a href="#2-kNN算法的代码实现" class="headerlink" title="2.kNN算法的代码实现"></a>2.kNN算法的代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kNN分类器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, label, k)</span>:</span></span><br><span class="line">    <span class="comment"># 获得dataSet的行数</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 在列向量方向上重复inX共1次(横向)，行向量方向上重复inX共dataSetSize次(纵向)</span></span><br><span class="line">    diffMat = np.tile(inX, (dataSetSize, <span class="number">1</span>)) - dataSet</span><br><span class="line">    <span class="comment"># 测试数据和训练数据相减后平方</span></span><br><span class="line">    sqDiffMat = diffMat ** <span class="number">2</span></span><br><span class="line">    <span class="comment"># 结果相加后开方</span></span><br><span class="line">    sqDistances = sqDiffMat.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistances ** <span class="number">0.5</span></span><br><span class="line">    <span class="comment"># 将距离排序，（argsort）返回数组从小到大的索引值</span></span><br><span class="line">    sortedDistanceIndex = distances.argsort()</span><br><span class="line">    <span class="comment"># 获取前k个分类结果</span></span><br><span class="line">    classCount = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        voteIlabel = label[sortedDistanceIndex[i]]</span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将分类结果得分排序</span></span><br><span class="line">    <span class="comment"># python3中用items()替换python2中的iteritems()</span></span><br><span class="line">    <span class="comment"># key=operator.itemgetter(1)根据字典的值进行排序</span></span><br><span class="line">    <span class="comment"># key=operator.itemgetter(0)根据字典的键进行排序</span></span><br><span class="line">    <span class="comment"># reverse降序排序字典</span></span><br><span class="line">    sortedClassCount = sorted(classCount.items(),</span><br><span class="line">                              key=operator.itemgetter(<span class="number">1</span>),</span><br><span class="line">                              reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="3-kNN算法的应用"><a href="#3-kNN算法的应用" class="headerlink" title="3.kNN算法的应用"></a>3.kNN算法的应用</h2><p>kNN算法的应用我使用的是《机器学习实战的例子》，书中代码是pyhon2实现，下面给出的代码是基于python3实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.lines <span class="keyword">as</span> mlines</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> kNN.kNN_base <span class="keyword">import</span> classify0</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    构建file2matrix函数，解决输入数据格式的问题</span></span><br><span class="line"><span class="string">    parameter</span></span><br><span class="line"><span class="string">        - filename: 文件名</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file2matrix</span><span class="params">(filename)</span>:</span></span><br><span class="line">    fr = open(filename)</span><br><span class="line">    <span class="comment"># 得到文件行数,readlines返回一个列表，列表每一项都是一行数据</span></span><br><span class="line">    arrayLines = fr.readlines()</span><br><span class="line">    numberOfLines = len(arrayLines)</span><br><span class="line">    <span class="comment"># 创建返回的numpy矩阵, 这里的三是以为有三个特征</span></span><br><span class="line">    returnMat = np.zeros((numberOfLines, <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># 分类标签向量集合</span></span><br><span class="line">    classLabelVector = []</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> arrayLines:</span><br><span class="line">        <span class="comment"># 删除首尾空格</span></span><br><span class="line">        line = line.strip()</span><br><span class="line">        listFromLine = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        returnMat[index, :] = listFromLine[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">        <span class="comment"># 1代表didntLike, 2代表smallDoses, 3代表largeDoses</span></span><br><span class="line">        classLabelVector.append(int(listFromLine[<span class="number">-1</span>]))</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnMat, classLabelVector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    可视化约会网站数据</span></span><br><span class="line"><span class="string">    :parameters</span></span><br><span class="line"><span class="string">        - dataMat: 特征方程</span></span><br><span class="line"><span class="string">        - dataLabels: 标签</span></span><br><span class="line"><span class="string">    :return</span></span><br><span class="line"><span class="string">        无</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showData</span><span class="params">(dataMat, dataLabels, x_label=<span class="string">'每年获得的飞行常客里程数'</span>, y_label=<span class="string">'玩游戏缩耗时间百分比'</span>)</span>:</span></span><br><span class="line">    colors = []</span><br><span class="line">    <span class="comment"># fig, axs = plt.subplots(nrows=2, ncols=2, sharex=False, sharey=False, figsize=(13, 8))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> color <span class="keyword">in</span> dataLabels:</span><br><span class="line">        <span class="keyword">if</span> color == <span class="number">1</span>:</span><br><span class="line">            colors.append(<span class="string">'red'</span>)</span><br><span class="line">        <span class="keyword">elif</span> color == <span class="number">2</span>:</span><br><span class="line">            colors.append(<span class="string">'yellow'</span>)</span><br><span class="line">        <span class="keyword">elif</span> color == <span class="number">3</span>:</span><br><span class="line">            colors.append(<span class="string">'black'</span>)</span><br><span class="line">    <span class="comment"># 以数据的第1列和第二列绘制散点图</span></span><br><span class="line">    <span class="comment"># axs[0][0].scatter(x=dataMat[:, 0], y=dataMat[:, 1])</span></span><br><span class="line">    <span class="comment"># 设置第一幅图的属性</span></span><br><span class="line">    <span class="comment"># axs0_title_text = axs[0][0].set_title(u'每年获得的飞行常客里程数与玩视频游戏所消耗时间占比')</span></span><br><span class="line">    <span class="comment"># axs0_xlabel_text = axs[0][0].set_xlabel(u'每年获得的飞行常客里程数')</span></span><br><span class="line">    <span class="comment"># axs0_ylabel_text = axs[0][0].set_ylabel(u'玩视频游戏所消耗时间占')</span></span><br><span class="line">    plt.scatter(np.transpose(dataMat)[<span class="number">0</span>], np.transpose(dataMat)[<span class="number">1</span>], c=colors)</span><br><span class="line">    plt.xlabel(x_label)</span><br><span class="line">    plt.ylabel(y_label)</span><br><span class="line">    didntLike = mlines.Line2D([], [], color=<span class="string">'black'</span>, marker=<span class="string">'.'</span>,</span><br><span class="line">                              markersize=<span class="number">6</span>, label=<span class="string">'didntLike'</span>)</span><br><span class="line">    smallDoses = mlines.Line2D([], [], color=<span class="string">'yellow'</span>, marker=<span class="string">'.'</span>,</span><br><span class="line">                               markersize=<span class="number">6</span>, label=<span class="string">'smallDoses'</span>)</span><br><span class="line">    largeDoses = mlines.Line2D([], [], color=<span class="string">'red'</span>, marker=<span class="string">'.'</span>,</span><br><span class="line">                               markersize=<span class="number">6</span>, label=<span class="string">'largeDoses'</span>)</span><br><span class="line">    plt.legend(handles=[didntLike, smallDoses, largeDoses])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    :parameter</span></span><br><span class="line"><span class="string">        - dataset: 数据集</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoNorm</span><span class="params">(dataset)</span>:</span></span><br><span class="line">    minVal = dataset.min(<span class="number">0</span>)</span><br><span class="line">    maxVal = dataset.max(<span class="number">0</span>)</span><br><span class="line">    dataRange = maxVal - minVal</span><br><span class="line">    m = dataset.shape[<span class="number">0</span>]</span><br><span class="line">    minVal = np.tile(minVal, (m, <span class="number">1</span>))</span><br><span class="line">    dataRange = np.tile(dataRange, (m, <span class="number">1</span>))</span><br><span class="line">    normMat = (dataset - minVal) / dataRange</span><br><span class="line">    <span class="keyword">return</span> normMat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    分类器针对约会网站的测试代码</span></span><br><span class="line"><span class="string">    :parameter</span></span><br><span class="line"><span class="string">        - dataMat: 数据集</span></span><br><span class="line"><span class="string">        - dataLabels: 数据集所对应的标签</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datingClassTest</span><span class="params">(dataMat, dataLabels)</span>:</span></span><br><span class="line">    hoRatio = <span class="number">0.10</span></span><br><span class="line">    normMat = autoNorm(dataMat)</span><br><span class="line">    m = normMat.shape[<span class="number">0</span>]</span><br><span class="line">    numTestVecs = int(m * hoRatio)</span><br><span class="line">    errorCount = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTestVecs):</span><br><span class="line">        classfierResult = classify0(normMat[i, :], normMat[numTestVecs:m, :],</span><br><span class="line">                                    datingLabels[numTestVecs:m], <span class="number">3</span>)</span><br><span class="line">        print(<span class="string">"the classifier came back with: %d, the real answer is: %d"</span> % (classfierResult, datingLabels[i]))</span><br><span class="line">        <span class="keyword">if</span> (classfierResult != datingLabels[i]):</span><br><span class="line">            errorCount += <span class="number">1.0</span></span><br><span class="line">    print(<span class="string">"the total error rate is: %f"</span></span><br><span class="line">          % (errorCount / float(numTestVecs)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    datingDataMat, datingLabels = file2matrix(<span class="string">'datingTestSet2.txt'</span>)</span><br><span class="line">    <span class="comment"># print(datingDataMat)</span></span><br><span class="line">    <span class="comment"># print("label", datingLabels)</span></span><br><span class="line">    <span class="comment"># # show约会网站上数据集</span></span><br><span class="line">    <span class="comment"># showData(datingDataMat, datingLabels)</span></span><br><span class="line">    <span class="comment"># 测试约会网站分类器</span></span><br><span class="line">    datingClassTest(datingDataMat, datingLabels)</span><br></pre></td></tr></table></figure><p>需要注意的是上述代码中试用了<code>autoNorm</code>函数对数据进行正则化，因为如果某一特征的差值过大的话，在最后计算出的距离中将会占有比较大的权重，对距离的计算影响较大。</p><p>还有就是上述代码只画出了两个特征对应的图，需要画其他图的稍微修改一些绘图代码即可。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-kNN算法简介&quot;&gt;&lt;a href=&quot;#1-kNN算法简介&quot; class=&quot;headerlink&quot; title=&quot;1.kNN算法简介&quot;&gt;&lt;/a&gt;1.kNN算法简介&lt;/h2&gt;&lt;p&gt;kNN的全称K Nearest Neighbors，又称K近邻算法。kNN算法是一种有监督学习的分类算法，原理很简单，甚至我们从名字上就能看出大概（k近邻也就是说找到k个邻居）。下面给出kNN算法的实现步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.输入一个待分类数据，确定K值（K值用来确定需要几个“邻居”）&lt;/li&gt;
&lt;li&gt;2.依次计算输入数据和训练数据距离（比如欧氏距离）&lt;/li&gt;
&lt;li&gt;3.将距离从小到大排序，获取前k个距离短的数据&lt;/li&gt;
&lt;li&gt;4.统计这k个数据所属的分类值，输出得分最高的分类作为该待分类数据所属的类别&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从实现步骤上来看很简单，实际上也确实是这样，因此kNN算法被称作最简单的分类算法，但是正是因为原理和实现都很简单kNN算法也成为了最常用的分类算法之一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="数据挖掘" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——单例模式</title>
    <link href="http://yoursite.com/2020/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-12T16:11:55.000Z</published>
    <updated>2020-10-12T16:13:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式算是最基础的一种设计模式，但是在工作中应用很广泛。单例模式的实现方式有很多种，大体上呈现出推进演变的趋势，大家常用的分类方式是将单例模式分为饿汉式和懒汉式，本文也将沿着单例模式演变的脉络介绍单例模式的实现方式。</p><p>首先学习一个东西需要了解这个技术是干什么的，解决了哪些问题。在开发中很多类的对象是不需要<code>new</code>多个对象，比如配置文件的对象存储了许多配置参数，并且通常这些配置参数是不变的，那么如果将该对象设计成唯一的就将复杂的配置简单化了，单例模式就是保证该类的对象只有一个的方法。</p><a id="more"></a><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>单例模式中饿汉模式。<br>饿汉模式中的类实例在类被加载时就被初始化出来了，因此在应用初始化的时会占用不必要的内存。同时，由于该实例在类被夹在的时候就创建出来了，所以它是线程安全的，因为类初始化是由<code>ClassLoader</code>完成的，而<code>Classloader</code>的<code>loadClass</code>方法在加载类的时候使用了<code>synchronized</code>关键字实现线程同步。</p><p>饿汉模式的代码示例如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton_01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton_01 instance = <span class="keyword">new</span> Singleton_01();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton_01</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton_01 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际使用中，这种实现方式是被推荐的，因为<strong>简单！！！</strong>而且是<strong>线程安全！！！</strong>的，但是它也存在一些问题。比如这个类不管在什么情况下都是实例化一个<code>Singleton_01</code>对象，那么假如这个类不被使用，那实例化这个对象的内存就被浪费了。那当然不行了！强迫症不能忍！我们试着对这个实现方式进行优化，于是就有了懒汉式实现单例方式。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>既然我们不想在类加载时候就实例化类对象，那我们就把它改一下，如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看好像没啥问题，但是我们考虑一下多线程环境下，假设<code>线程一</code>执行了到了<code>INSTANCE==null</code>这条语句判断为空但是还没有执行到<code>new Singleton()</code>这条语句，这时候<code>线程二</code>刚好也执行到了<code>INSTANCE==null</code>这条语句，那么它也会判断为空，这样就实例化了两个对象。因此这种实现方式是线程不安全的，好的那么我们都知道<code>synchronized</code>是可以锁住对象保证线程安全的，我们将上面的代码改成如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的实现方式当然是线程安全的，但是直接锁住一个方法，是否会对性能造成影响呢？答案是肯定的，在多线程环境下每个线程想要获取<code>Singleton</code>对象都需要去获得这把锁，而这个方法中也许会有一些业务代码是不需要上锁的，这样粗暴的上锁方式是不合适的并且代码效率也不高，那我们当然不能忍！于是就有了下面的解决方案，细化锁，我们只对实例化操作上锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是不幸的是，和上面一样，这种实现方式也是线程不安全的。因为在一个线程获取锁时，另一个线程可能也进入了这个判断，在等待前一个线程释放锁，这样也可能发生实例化对象不唯一的错误。可能这时候你会有疑惑，为什么不在<code>if</code>条件判断外面上锁，这个问题很好想明白，如果这样做的话任然是每次获取这个<code>INSTANCE</code>都需要去获取锁。为了解决上面这种实现方式的问题，双重检查的懒汉式单例实现就出来了，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样即使另外一个线程等待锁的释放由于内部还有一重检查，也不会创建第二个实例对象，保证了线程安全。</p><p>需要注意的是，<code>INSTANCE</code>的<code>volatile</code>关键字不能少。原因是这样禁止了实例化<code>Singleton</code>对象时发生指令重排序，在<code>JVM</code>中实例化对象并不是一个原子操作，而是分为三步：<strong>开辟空间</strong>、<strong>成员变量赋值</strong>、<strong>内存空间指向该对象的引用</strong>。在<code>java</code>代码编译过程中为了提高效率，会对执行顺序进行优化，也就是指令重排序，我们想象一下这样的场景：先开辟空间再将内存空间地址指向该对象的引用，最后为成员变量赋值，那么这个时候另一个线程执行到<code>if(INSTANCE == null)</code>这时该线程会判断当前<code>INSTANCE</code>对象不为空，将直接返回<code>INSTANCE</code>，但是这时候该对象并未进行赋值操作，这会使得我们得到了一个错误的数据，同样是线程不安全的。因此<code>volatile</code>关键字是需要加上的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;单例模式算是最基础的一种设计模式，但是在工作中应用很广泛。单例模式的实现方式有很多种，大体上呈现出推进演变的趋势，大家常用的分类方式是将单例模式分为饿汉式和懒汉式，本文也将沿着单例模式演变的脉络介绍单例模式的实现方式。&lt;/p&gt;
&lt;p&gt;首先学习一个东西需要了解这个技术是干什么的，解决了哪些问题。在开发中很多类的对象是不需要&lt;code&gt;new&lt;/code&gt;多个对象，比如配置文件的对象存储了许多配置参数，并且通常这些配置参数是不变的，那么如果将该对象设计成唯一的就将复杂的配置简单化了，单例模式就是保证该类的对象只有一个的方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_312</title>
    <link href="http://yoursite.com/2020/07/20/LeetCode-312/"/>
    <id>http://yoursite.com/2020/07/20/LeetCode-312/</id>
    <published>2020-07-20T08:46:37.000Z</published>
    <updated>2020-07-20T09:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>312.戳气球</strong></p><hr><p>有<code>n</code>个气球，编号为<code>0</code>到<code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p><p>现在要求你戳破所有气球。如果你戳破气球<code>i</code>，就可以获得<code>nums[left]*nums[i]*nums[right]</code>个硬币。这里的<code>left</code>和<code>right</code>代表和<code>i</code>相邻的两个气球的序号。注意当你戳破了气球<code>i</code>后，气球<code>left</code>和气球<code>right</code>就编程了相邻的气球。</p><p>求所能获得的硬币最大数量。</p><p><strong>说明：</strong>    </p><pre><code>* 那你可以假设`nums[-1] = nums[n] = 1`，但注意它们不是真实存在的，所以不能被戳破。* 0&lt;=`n`&lt;=500, 0&lt;=`nums[i]`&lt;=100</code></pre><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[3, 1, 5, 8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 &#x3D; 167</span><br></pre></td></tr></table></figure><a id="more"></a><hr><p><strong>解题思路</strong></p><p><strong>解法一：</strong>回溯法</p><p>本题使用回溯法是以一种暴力求解的方式解决此问题，通过遍历所有的可能，找到最大值。下面给出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">           list.add(num);</span><br><span class="line">       &#125;</span><br><span class="line">       helper(list, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> total;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(List&lt;Integer&gt; nums, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> curCoins = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           total = Math.max(coins, total);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> temp = nums.get(i);</span><br><span class="line">           curCoins = nums.get(i) * (i - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">1</span> : nums.get(i - <span class="number">1</span>)) * (i + <span class="number">1</span> == nums.size() ? <span class="number">1</span> : nums.get(i + <span class="number">1</span>));</span><br><span class="line">           nums.remove(i);</span><br><span class="line">           helper(nums, curCoins + coins);</span><br><span class="line">           nums.add(i, temp);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>稍微解释一下上面的代码，为了操作方便 ，我这里选择了用<code>List</code>代替整型数组。通过递归的方式对所有的可能进行遍历，递归函数的参数<code>nums</code>和<code>coins</code>分别代表当前数组以及获得的硬币的数量。递归的出口就是当前数组为空，并且当数组为空时与之前所求得的硬币最大值比较，看当前方法获得的硬币是否为最大值。这里值得注意的是，删除完元素后别忘记了加回去。</p><p>回溯法虽然能得到正确的结果，但是不难看出，时间复杂度为<code>O(n!)</code>。一般来说<code>O(n!)</code>的时间复杂度在<code>n &gt; 10</code>的条件下就通不过了，而这里的<code>n</code>是<code>[0, 500]</code>，因此该方法并不能通过。</p><p><strong>解法二：</strong>动态规划</p><p>动态规划的核心是找到状态转移方程，将问题划分为两个最佳子问题。从正向考虑，将第<code>i</code>个气球看成是当前要戳爆的气球的话，子问题就划分在<code>[0, i - 1]</code>和<code>[i + 1, n)</code>这两个区间。但是根据规则，戳爆了第<code>i</code>个气球之后，第<code>i - 1</code>和第<code>i + 1</code>个气球直接相关，这样我们就没法将两个区间看成是独立的子问题。</p><p>所以，不妨逆向考虑，将第<code>i</code>个气球当成是最后被戳爆的气球。那么，<code>[0, i - 1]</code>和<code>[i + 1, n)</code>就只和<code>i</code>相关了，这样就可以将两个区间看成是相互独立的子问题了。</p><p>建立<code>dp[i][j]</code>数组代表从<code>i</code>到<code>j</code>所能获得硬币的最大数量，<code>k(i &lt;= k &lt;= j)</code>代表了当前第<code>k</code>个气球被戳爆。那么这个状态转移方程就可以写成<code>dp[i][j] = dp[i][k - 1] + dp[k + 1][j] + nums[i - 1] * nums[k] * nums[j + 1]</code>。下面给出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">2</span>][nums.length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        list.add(nums.length + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        helper(list, <span class="number">1</span>, nums.length);</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][nums.length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(List&lt;Integer&gt; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = helper(nums, i, k - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> right = helper(nums, k + <span class="number">1</span>, j);</span><br><span class="line">            <span class="keyword">int</span> delta = nums.get(i - <span class="number">1</span>) * nums.get(k) * nums.get(j + <span class="number">1</span>);</span><br><span class="line">            dp[i][j] = Math.max(dp[i][j], left + right + delta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这种实现方法的时间复杂度还是<code>O(n!)</code>，但是不同是的<code>dp[i][j]</code>数组可以记录从<code>i</code>到<code>j</code>所能获得的硬币数量，可以进行剪枝操作，避免了重复计算。</p><p><strong>后记</strong></p><p>最初这道题我的想法是用贪心来解决，思路是找到一个气球周围两个气球的乘积的最大值，并点爆这个气球（若乘积相同则点爆硬币小的气球）。结果试验后发现这个想法是错的，于是想用动态规划的方法解决，然而并没有找到状态转移方程。最终上述的代码是我看别人的解题思路后实现的，希望以后碰见这类问题可以有一个快速的反应，也希望自己的算法水平能提高，加油。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;312.戳气球&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;有&lt;code&gt;n&lt;/code&gt;个气球，编号为&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;n-1&lt;/code&gt;，每个气球上都标有一个数字，这些数字存在数组&lt;code&gt;nums&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;现在要求你戳破所有气球。如果你戳破气球&lt;code&gt;i&lt;/code&gt;，就可以获得&lt;code&gt;nums[left]*nums[i]*nums[right]&lt;/code&gt;个硬币。这里的&lt;code&gt;left&lt;/code&gt;和&lt;code&gt;right&lt;/code&gt;代表和&lt;code&gt;i&lt;/code&gt;相邻的两个气球的序号。注意当你戳破了气球&lt;code&gt;i&lt;/code&gt;后，气球&lt;code&gt;left&lt;/code&gt;和气球&lt;code&gt;right&lt;/code&gt;就编程了相邻的气球。&lt;/p&gt;
&lt;p&gt;求所能获得的硬币最大数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 那你可以假设`nums[-1] = nums[n] = 1`，但注意它们不是真实存在的，所以不能被戳破。
* 0&amp;lt;=`n`&amp;lt;=500, 0&amp;lt;=`nums[i]`&amp;lt;=100&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[3, 1, 5, 8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 167 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: nums &amp;#x3D; [3,1,5,8] --&amp;gt; [3,5,8] --&amp;gt; [3,8] --&amp;gt; [8] --&amp;gt; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     coins &amp;#x3D;  3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 &amp;#x3D; 167&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_96</title>
    <link href="http://yoursite.com/2020/07/15/LeetCode-96/"/>
    <id>http://yoursite.com/2020/07/15/LeetCode-96/</id>
    <published>2020-07-15T04:47:40.000Z</published>
    <updated>2020-07-16T07:49:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>96.不同的二叉搜索树</strong></p><hr><p>给定一个整数n，求以1…n为节点组成的二叉搜索树有多少种？</p><p><strong>示例</strong></p><blockquote><p>输入：3</p><p>输出：5</p><p>给定n = 3，一共有5种不同结构的二叉搜索树</p><p>1         3         3       2          1<br> \         /         /        / \           <br>  3     2        1        1   3            2<br> /     /            \                            <br>2     1             2                           3</p></blockquote><a id="more"></a><p><strong>解题思路</strong></p><p>这道题其实是一道动态规划题。假设 <code>dp(n)</code>为n个数所组成的二叉搜索树的数量，f(i)为以i为节点能构成几个二叉搜索树。那么<code>dp(n) = f(1) + f(2) + f(3) + ... + f(n)</code></p><p>那么接下来我们看<code>f(i)</code>等于什么，我们都知道，二叉搜索树是任意节点的左孩子都小于该节点，任意节点的右孩子都大于该节点。换句话说，假设<code>i</code>为根节点的话，那么<code>i</code>左边有<code>1,2,3,...,i-1</code>这些节点（共<code>i-1</code>个），右边有<code>i+1,i+2,...,n</code>（共<code>n-i</code>个），那么也就是说<code>f(i) = dp[i-1] * dp[n - i]</code>，知道了<code>f(i)</code>也就可以求出<code>dp[n]</code>了。接下来让我们来进行代码实现吧！</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_96</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = numTrees(<span class="number">3</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后记</strong></p><p>动态规划问题找出递推式是关键。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;96.不同的二叉搜索树&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;给定一个整数n，求以1…n为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：3&lt;/p&gt;
&lt;p&gt;输出：5&lt;/p&gt;
&lt;p&gt;给定n = 3，一共有5种不同结构的二叉搜索树&lt;/p&gt;
&lt;p&gt;1         3         3       2          1&lt;br&gt; \         /         /        / \           &lt;br&gt;  3     2        1        1   3            2&lt;br&gt; /     /            \                            &lt;br&gt;2     1             2                           3&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
